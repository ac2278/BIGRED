source(paste(functionpath, "normGL-function.R", sep="/"))
source(paste(functionpath, "thin-function.R", sep="/"))
source(paste(functionpath, "simulate-function.R", sep="/"))
source(paste(functionpath, "searchVCF-function.R", sep="/"))
source(paste(functionpath, "merge-function.R", sep="/"))
source(paste(functionpath, "PL-function.R", sep="/"))
source(paste(functionpath, "FORMAT-function.R", sep="/"))
source(paste(functionpath, "importdata-function.R", sep="/"))
Ik6 <- enumerateI(k=6)
Ik6
Gk6 <- enumerateG_revised(k=6, I.list=Ik6)
names(Gk6)
Gk6[1]
k6 <- list('enumerateI'=Ik6, 'enumerateG'=Gk6)
names(k6)
saveRDS(k6, "k6.rds")
computer <- "ariel"
program <- "IITA"
if(computer=="ariel"){ directory <- paste("/Volumes/CHARLIE/pheno_data/", program, sep=""); functionpath <- "/Users/ac2278/Desktop/Rfunctions"}
if(computer=="roberto"){ directory <- paste("/home/DB2/ariel/pheno_data/", program, sep=""); functionpath <- "/home/DB2/ariel/Rfunctions" }
if(computer=="marnin"){ directory <- paste("/Users/ac2278/DB2/", program, sep=""); functionpath <- "/Users/ac2278/DB2/Rfunctions" }
setwd(directory)
if(program=="IITA"){ database <- read.csv("IITA_PhenoNames_AssociatedToVCFnames_83116.csv", check.names=F);
names(database)[grep("CLONE.fix2", names(database))] <- "CLONE" }
if(program=="NaCRRI"){ database <- read.csv("NaCRRI_PhenoNames_AssociatedToVCFnames_83116.csv", check.names=F) }
if(program=="NRCRI"){ database <- read.csv("NRCRI_PhenoNames_AssociatedToVCFnames_83116.csv", check.names=F);
names(database)[grep("CLONE.fix", names(database))] <- "CLONE" }
replicates <- as.character(database$VCFnames)
names(replicates) <- database$CLONE
replicates <- strsplit(replicates, "\\|")
replicates <- replicates[rapply(replicates,length)>1]
replicates[20]
getwd()
replicates[[20]]
grep("Z930151", replicates)
grep("Z930151", replicates, value=T)
replicates[20]
computer <- "ariel"
program <- "IITA"
if(computer=="ariel"){ directory <- paste("/Volumes/CHARLIE/pheno_data/", program, sep=""); functionpath <- "/Users/ac2278/Desktop/Rfunctions"}
if(computer=="roberto"){ directory <- paste("/home/DB2/ariel/pheno_data/", program, sep=""); functionpath <- "/home/DB2/ariel/Rfunctions" }
if(computer=="marnin"){ directory <- paste("/Users/ac2278/DB2/", program, sep=""); functionpath <- "/Users/ac2278/DB2/Rfunctions" }
setwd(directory)
if(program=="IITA"){ database <- read.csv("IITA_PhenoNames_AssociatedToVCFnames_83116.csv", check.names=F);
names(database)[grep("CLONE.fix2", names(database))] <- "CLONE" }
replicates <- as.character(database$VCFnames)
names(replicates) <- database$CLONE
replicates <- strsplit(replicates, "\\|")
replicates <- replicates[rapply(replicates,length)>1]
grep("010040", replicates, value=T)
write.table(paste(header$CHROM, header$POS), "chr001.snpfile", row.names=F, col.names=F, quote=F, sep="\t")
replicates[1]
IITA_merge <- read.table("/Volumes/CHARLIE/pheno_data/IITA_merge.log", header=TRUE, quote="\"")
View(IITA_merge)
replicates[2]
nchar("10045229621")
View(IITA_merge)
IITA_merge$mergestatus
table(IITA_merge$mergestatus)
computer <- "ariel"
program <- "IITA"
if(computer=="ariel"){ directory <- paste("/Volumes/CHARLIE/pheno_data/", program, sep=""); functionpath <- "/Users/ac2278/Desktop/Rfunctions"}
if(computer=="roberto"){ directory <- paste("/home/DB2/ariel/pheno_data/", program, sep=""); functionpath <- "/home/DB2/ariel/Rfunctions" }
if(computer=="marnin"){ directory <- paste("/Users/ac2278/DB2/", program, sep=""); functionpath <- "/Users/ac2278/DB2/Rfunctions" }
setwd(directory)
if(program=="IITA"){ database <- read.csv("IITA_PhenoNames_AssociatedToVCFnames_83116.csv", check.names=F);
names(database)[grep("CLONE.fix2", names(database))] <- "CLONE" }
View(database)
replicates <- as.character(database$VCFnames)
names(replicates) <- database$CLONE
replicates <- strsplit(replicates, "\\|")
replicates <- replicates[rapply(replicates,length)>1]
rapply(length, replicates)
rapply(replicates, length)
head(rapply(replicates, length))
replicates["TMEB1"]
replciates[["TME693"]]
replicates$TME693
replicates[["TME693"]]
replicates[["TME117"]]
96*4
96/2
source(paste(functionpath, "normGL-function.R", sep="/"))
normGL("2,1", 0.01)
normGL
normGL("2,1", 0.01, coding="character")
normGL("2,1", 0e=.01, coding="character")
normGL("2,1", e=0.01, coding="character")
normGL("2,1", e=0.01, callthreshold=NA, coding="character")
0.9266123054/0.0726538176
normGL("5,1", e=0.01, callthreshold=NA, coding="character")
6.216456e-01/3.783544e-01
source(paste(functionpath, "PL-function.R", sep="/"))
PL
PL("5,1", 0.01)
normGL("5,1", 0.01, NA, "character")
.38+.62
normGL("10,0", 0.01, NA, "character")
PL("10,0", 0.01)
9.989214e-01/1.078647e-03
source(paste(functionpath,"dosage-function.R", sep="/")
)
source(paste(functionpath,"dosage-function.R", sep="/"))
dosage("10,1", 0.01)
dosage("5,1", 0.01)
rapply(length, replicates)
rapply(replicates, length)
rapply(replicates, length)==3
grep(T, rapply(replicates, length)==3)
replicates[2]
replicates[6]
replicates[7]
replicates[14]
replicates[17]
replicates[grep(T, rapply(replicates, length)==3)]
source(paste(functionpath, "enumerateG_revised-function.R", sep="/"))
computer <- "ariel"
enumerateG_revisedfunctionpath <- "/Users/ac2278/Desktop/Rfunction"
functionpath <- "/Users/ac2278/Desktop/Rfunction"
rm(enumerateG_revisedfunctionpath)
require(gtools)
require(parallel)
source(paste(functionpath, "enumerateI-function.R", sep="/"))
functionpath <- "/Users/ac2278/Desktop/Rfunctions"
source(paste(functionpath, "enumerateI-function.R", sep="/"))
I.list<- enumerateI(k=3)
I.list
require(gtools)
require(parallel)
I <- do.call(rbind, unlist(I.list, recursive=F))
I
rownames(I) <- paste("I=", apply(I, 1, function(i) paste(i, collapse=",")), sep="")
G <- permutations(n=3, r=k, v=c("AA","AB","BB"), repeats.allowed=T)
k <- 3
G <- permutations(n=3, r=k, v=c("AA","AB","BB"), repeats.allowed=T)
G
rownames(G) <- apply(G, 1, function(g) paste(g, collapse=","))
colnames(G) <- paste("d=", 1:k, sep="")
membership <- apply(G, 1, function(g){ x <- length(unique(g));
putative <- do.call(rbind, unlist(I.list[x:k], recursive=F))
rownames(putative) <- apply(putative, 1, function(i) paste(i, collapse=","))
consistent = apply(putative, 1, function(evaluate){
count = 0
for (i in 1:k){
test = length(unique(g[evaluate==i]))>1
if(test==T){ break } else count = count + 1
}
return(count)
})
return(paste("I=",names(consistent[consistent==k]),sep="")) })
membership
enumerateGgivenI <- sapply(setNames(rownames(I), rownames(I)), function(i) names(grep(T, rapply(membership, function(x) ifelse(length(intersect(x,i))==1, T, F)), value=T)))
enumerateGgivenI
enumerateG_revised = function(k, I.list){
require(gtools)
require(parallel)
# (1) Supply a list of all possible identity vectors of length k (i.e. I.list).
#     We index each identity vector using i.
I <- do.call(rbind, unlist(I.list, recursive=F))
rownames(I) <- paste("I=", apply(I, 1, function(i) paste(i, collapse=",")), sep="")
# (2) Enumerate all possible genotype vectors of length k. (indexed by g)
G <- permutations(n=3, r=k, v=c("AA","AB","BB"), repeats.allowed=T)
rownames(G) <- apply(G, 1, function(g) paste(g, collapse=","))
colnames(G) <- paste("d=", 1:k, sep="")
# (3) We answer the question "Does g belong to category i?".
membership <- apply(G, 1, function(g){ x <- length(unique(g));
putative <- do.call(rbind, unlist(I.list[x:k], recursive=F))
rownames(putative) <- apply(putative, 1, function(i) paste(i, collapse=","))
consistent = apply(putative, 1, function(evaluate){
count = 0
for (i in 1:k){
test = length(unique(g[evaluate==i]))>1
if(test==T){ break } else count = count + 1
}
return(count)
})
return(paste("I=",names(consistent[consistent==k]),sep="")) })
enumerateGgivenI <- sapply(setNames(rownames(I), rownames(I)), function(i) names(grep(T, rapply(membership, function(x) ifelse(length(intersect(x,i))==1, T, F)), value=T)))
# We return a list of length two:
#      (1) `G|I`: (list) enumerates all genotype vectors consistent with identity vector i
#      (2) `P(G|I)`: (vector) provides the probability of genotype vector g given identity vector i.
#                    We compute P(G|I) assuming (for now) the uniform probability law (i.e. 1/cardinality of set).
return(list("G"=G, "G|I"=enumerateGgivenI, "P(G|I)"=rapply(enumerateGgivenI, function(x) setNames(rep(1/length(x), length(x)), x), how="list")))
}
S <- enumerateI(k)
reference <- enumerateG_revised(k, S)
reference
step1 <- sapply(reference[["G|I"]], function(x) do.call(rbind, strsplit(x, ",")))
step1
step2 <- rapply(strsplit(gsub("I=","",I), ","), duplicated, how="list")
step3 <- mapply(function(x,y){ y <- ifelse(y==F,T,F);
z <- as.matrix(x[,y]); return(z) }, x=step1, y=step2)
step3
step2
I <- names(reference[["P(G|I)"]])
step1 <- sapply(reference[["G|I"]], function(x) do.call(rbind, strsplit(x, ",")))
step2 <- rapply(strsplit(gsub("I=","",I), ","), duplicated, how="list")
step3 <- mapply(function(x,y){ y <- ifelse(y==F,T,F);
z <- as.matrix(x[,y]); return(z) }, x=step1, y=step2)
step3
computer <- "ariel"
IITA_merge <- read.table("/Volumes/CHARLIE/pheno_data/IITA_merge.log", header=TRUE, quote="\"", stringsAsFactors=FALSE)
View(IITA_merge)
program <- "IITA"
if(computer=="ariel"){ directory <- paste("/Volumes/CHARLIE/pheno_data/", program, sep=""); functionpath <- "/Users/ac2278/Desktop/Rfunctions"}
if(computer=="roberto"){ directory <- paste("/home/DB2/ariel/pheno_data/", program, sep=""); functionpath <- "/home/DB2/ariel/Rfunctions" }
if(computer=="marnin"){ directory <- paste("/Users/ac2278/DB2/", program, sep=""); functionpath <- "/Users/ac2278/DB2/Rfunctions" }
setwd(directory)
if(program=="IITA"){ database <- read.csv("IITA_PhenoNames_AssociatedToVCFnames_83116.csv", check.names=F);
names(database)[grep("CLONE.fix2", names(database))] <- "CLONE" }
if(program=="NaCRRI"){ database <- read.csv("NaCRRI_PhenoNames_AssociatedToVCFnames_83116.csv", check.names=F) }
if(program=="NRCRI"){ database <- read.csv("NRCRI_PhenoNames_AssociatedToVCFnames_83116.csv", check.names=F);
names(database)[grep("CLONE.fix", names(database))] <- "CLONE" }
replicates <- as.character(database$VCFnames)
names(replicates) <- database$CLONE
replicates <- strsplit(replicates, "\\|")
replicates <- replicates[rapply(replicates,length)>1]
replicates[3]
replicates[5]
replicates[7]
L <- 10
sample(0:2, 10)
sample(0:2, 10, replace=T)
reference <- sample(0:2, 10, replace=T)
reference
reference <- matrix(nrow=L*5, ncol=5)
n <- 5
sample(0:2, L*5, replace=T)
reference <-  matrix(sample(0:2, L*5, replace=T), nrow=L*5, ncol=5)
reference
reference <-  matrix(sample(0:2, L*5, replace=T), nrow=L*n, ncol=L)
reference
reference <-  matrix(sample(0:2, L*n, replace=T), nrow=n, ncol=L)
reference
reference <-  matrix(sample(0:1, L*n, replace=T), nrow=n, ncol=L)
reference
source(paste(functionpath, "normGL-function.R", sep="/"))
normGL(x="5,1", error=0.01, callthreshold=NA, coding="character")
as.matrix(normGL(x="5,1", error=0.01, callthreshold=NA, coding="character"))
normGL(x="5,1", error=0.01, callthreshold=NA, coding="character")
normGL(x="10,0", error=0.01, callthreshold=NA, coding="character")
getwd()
computer <- "ariel"
program <- "IITA"
if(computer=="ariel"){ directory <- paste("/Volumes/CHARLIE/pheno_data/", program, sep=""); functionpath <- "/Users/ac2278/Desktop/Rfunctions"}
if(computer=="roberto"){ directory <- paste("/home/DB2/ariel/pheno_data/", program, sep=""); functionpath <- "/home/DB2/ariel/Rfunctions" }
if(computer=="marnin"){ directory <- paste("/Users/ac2278/DB2/", program, sep=""); functionpath <- "/Users/ac2278/DB2/Rfunctions" }
setwd(directory)
if(program=="IITA"){ database <- read.csv("IITA_PhenoNames_AssociatedToVCFnames_83116.csv", check.names=F);
names(database)[grep("CLONE.fix2", names(database))] <- "CLONE" }
if(program=="NaCRRI"){ database <- read.csv("NaCRRI_PhenoNames_AssociatedToVCFnames_83116.csv", check.names=F) }
if(program=="NRCRI"){ database <- read.csv("NRCRI_PhenoNames_AssociatedToVCFnames_83116.csv", check.names=F);
names(database)[grep("CLONE.fix", names(database))] <- "CLONE" }
replicates <- as.character(database$VCFnames)
names(replicates) <- database$CLONE
replicates <- strsplit(replicates, "\\|")
replicates <- replicates[rapply(replicates,length)>1]
replicates <- replicates[sapply(replicates, length)<9]  # skip TMEB419 and NA
getwd()
require("knitr")
computer <- "ariel"
program <- "IITA"
if(computer=="ariel"){ directory <- paste("/Volumes/CHARLIE/pheno_data/", program, sep=""); functionpath <- "/Users/ac2278/Desktop/Rfunctions"}
if(computer=="roberto"){ directory <- paste("/home/DB2/ariel/pheno_data/", program, sep=""); functionpath <- "/home/DB2/ariel/Rfunctions" }
if(computer=="marnin"){ directory <- paste("/Users/ac2278/DB2/", program, sep=""); functionpath <- "/Users/ac2278/DB2/Rfunctions" }
opts_knit$set(root.dir = directory)
getwd()
getwd()
if(program=="IITA"){ database <- read.csv("IITA_PhenoNames_AssociatedToVCFnames_83116.csv", check.names=F);
names(database)[grep("CLONE.fix2", names(database))] <- "CLONE" }
if(program=="IITA"){ database <- read.csv("IITA_PhenoNames_AssociatedToVCFnames_83116.csv", check.names=F);
names(database)[grep("CLONE.fix2", names(database))] <- "CLONE" }
if(program=="NaCRRI"){ database <- read.csv("NaCRRI_PhenoNames_AssociatedToVCFnames_83116.csv", check.names=F) }
if(program=="NRCRI"){ database <- read.csv("NRCRI_PhenoNames_AssociatedToVCFnames_83116.csv", check.names=F);
names(database)[grep("CLONE.fix", names(database))] <- "CLONE" }
replicates <- as.character(database$VCFnames)
names(replicates) <- database$CLONE
replicates <- strsplit(replicates, "\\|")
replicates <- replicates[rapply(replicates,length)>1]
replicates <- replicates[sapply(replicates, length)<9]  # skip TMEB419 and NA
table(sapply(replicates, length))
pEM <- readRDS("pEM_IITA.rds")
pEM <- readRDS("pEM_IITA.rds")
pEM
mafrange <- c(0.4,0.5); L <- 1000; thinby <- 20000; chrom <- 1:18
I <- "11"
lambdas <- list(c(0.5,  2),
c(0.5,  4),
c(0.5,  6),
c(0.5, 12))
n <- 100
headersuffix <- "header"
prefix <- paste(L, I, lambda, paste(mafrange, collapse=","), sep="_")
lambda <- lambdas[[1]]
lambda
prefix <- paste(L, I, lambda, paste(mafrange, collapse=","), sep="_")
prefix
prefix <- paste(L, I, paste(lambda, collapse=","), paste(mafrange, collapse=","), sep="_")
prefix
prefix <- paste(L, paste(I, collapse=","), paste(lambda, collapse=","), paste(mafrange, collapse=","), sep="_")
prefix
I
prefix <- paste(L, I, paste(lambda, collapse=","), paste(mafrange, collapse=","), sep="_")
prefix
require('snprelate')
require(SNPRelate)
hapmix_mode <- "DIPLOID"                # "LOCAL_ANC"
output_details <- "HAPLOID_FILES"       # "ANC_EXPECTED"
admixprefix <- "admix001"
chrompad <- 001
paste("run.", hapmix_mode, output_details, admixprefix, ".chr", chrompad, sep="")
paste("run.", hapmix_mode, output_details, ".", admixprefix, ".chr", chrompad, sep="")
admix <- read.table("/Volumes/CHARLIE/introgression/admix.txt", quote="\"")
View(admix)
admix001.DIPLOID.GENOHAP1 <- read.table("/Volumes/CHARLIE/introgression/admix001.DIPLOID.GENOHAP1.1", quote="\"", stringsAsFactors=FALSE)
View(admix001.DIPLOID.GENOHAP1)
dim(admix001.DIPLOID.GENOHAP1)
require('rrBLUP')
ma <- matrix(c(1:4, 1, 6:8), nrow = 2)
ma
apply(ma, 1, table)
apply(ma[1,], 1, table)
ma[1,]
ma <- matrix(c(1:4, 1, 6:8), nrow = 3)
ma <- matrix(1:9, nrow = 3)
ma
apply(ma, 1, table)
v <- setNames(c(3,1), c("A", "T"))
v
rep(names(v), v)
list1<-list(a=c(0,1,2),b=c(3,4,5));
list2<-list(a=c(7,8,9),b=c(10,11,12));
list1
list2
l<-lapply(names(list1),function(x) rbind(list1[[x]],list2[[x]]))
l
a <- table(c(rep(1,2), 4)
)
a
b <- table(c(rep(1,2), 4))
cbind(a,b)
b
b <- table(c(rep(1,2), 6))
cbind(a,b)
combn(letters[1:4], 2)
require(gtools)
functionpath <- "/Users/ac2278/Desktop/Rfunctions/"
source(paste(functionpath, "enumerateG_revised-function.R", sep="/"))
source(paste(functionpath, "enumerateI-function.R", sep="/"))
enumerateI()
enumerateI(k=4)
enumerateI
require(gtools); require(stringr)
enumerateI(k=4)
do.call(rbind, enumerateI(k=4))
do.call(rbind, unlist(enumerateI(k=4)))
unlist(enumerateI(4))
unlist(enumerateI(4), recursive=F)
do.call(rbindunlist(enumerateI(4), recursive=F))
do.call(rbind,unlist(enumerateI(4), recursive=F))
do.call(rbind,unlist(enumerateI(5), recursive=F))
do.call(rbind,unlist(enumerateI(6), recursive=F))
do.call(rbind,unlist(enumerateI(7), recursive=F))
do.call(rbind,unlist(enumerateI(8), recursive=F))
1250+2890
factorial(2)
factorial(3)
factorial(4)
factorial(5)
factorial(6)
factorial(7)
877*4
4140-3508
log2(632)
2^9
mode(0.01)
class(0.01)
enumerateG_revised = function(k, I.list){
require(gtools)
require(parallel)
# (1) Supply a list of all possible identity vectors of length k (i.e. I.list).
#     We index each identity vector using i.
I <- do.call(rbind, unlist(I.list, recursive=F))
rownames(I) <- paste("I=", apply(I, 1, function(i) paste(i, collapse=",")), sep="")
# (2) Enumerate all possible genotype vectors of length k. (indexed by g)
G <- permutations(n=3, r=k, v=c("AA","AB","BB"), repeats.allowed=T)
rownames(G) <- apply(G, 1, function(g) paste(g, collapse=","))
colnames(G) <- paste("d=", 1:k, sep="")
# (3) We answer the question "Does g belong to category i?".
membership <- apply(G, 1, function(g){ x <- length(unique(g));
putative <- do.call(rbind, unlist(I.list[x:k], recursive=F))
rownames(putative) <- apply(putative, 1, function(i) paste(i, collapse=","))
consistent = apply(putative, 1, function(evaluate){
count = 0
for (i in 1:k){
test = length(unique(g[evaluate==i]))>1
if(test==T){ break } else count = count + 1
}
return(count)
})
return(paste("I=",names(consistent[consistent==k]),sep="")) })
enumerateGgivenI <- sapply(setNames(rownames(I), rownames(I)), function(i) names(grep(T, rapply(membership, function(x) ifelse(length(intersect(x,i))==1, T, F)), value=T)))
# We return a list of length two:
#      (1) `G|I`: (list) enumerates all genotype vectors consistent with identity vector i
#      (2) `P(G|I)`: (vector) provides the probability of genotype vector g given identity vector i.
#                    We compute P(G|I) assuming (for now) the uniform probability law (i.e. 1/cardinality of set).
return(list("G"=G, "G|I"=enumerateGgivenI, "P(G|I)"=rapply(enumerateGgivenI, function(x) setNames(rep(1/length(x), length(x)), x), how="list")))
}
enumerateI = function(k){
require(stringr)
A <- 1:(k-1)
composition <- k
input <- setNames(1:k,1:k)
count <- 1
while(count<k){
output = unlist(sapply(input, function(x) structure(x+A,names=A), simplify=F))              #
composition = c(composition, names(output[output==k]))                                      # Output outcome if the elements sum to k
input = output[output<k]                                                                    # Eliminate outcome if the elements sum to >k
count = count + 1
}
composition = gsub("[.]", "", composition)                                                    # Replace all "." with "".
composition = str_pad(composition, k, side="right", pad="0")                                  #
order = sapply(composition, function(x) matrix(rep(1:k, times=unlist(strsplit(x,""))), ncol=k), simplify=F)
for (i in 2:(length(composition)-1)){                                                         #
composition.permutation = cbind(1, unique(permutations(k-1, k-1, order[[i]][,2:k], set=F)))
# Identify the subset of permutations that satisfy constraint (1):
order[[i]] = matrix(composition.permutation[apply(composition.permutation, 1, function(x){
length(unlist(sapply(2:k, function(i) setdiff(1:(x[i]), x[1:i]))))==0 }),], ncol=k)
}
nS = rapply(order, function(x) length(table(x)))
I = sapply(setNames(1:k,paste("s=",1:k,sep="")), simplify=F, function(s) order[nS==s])
return(I)
}
enumerateI(3)
enumerateI = function(k){
require(stringr); require(gtools)
A <- 1:(k-1)
composition <- k
input <- setNames(1:k,1:k)
count <- 1
while(count<k){
output = unlist(sapply(input, function(x) structure(x+A,names=A), simplify=F))              #
composition = c(composition, names(output[output==k]))                                      # Output outcome if the elements sum to k
input = output[output<k]                                                                    # Eliminate outcome if the elements sum to >k
count = count + 1
}
composition = gsub("[.]", "", composition)                                                    # Replace all "." with "".
composition = str_pad(composition, k, side="right", pad="0")                                  #
order = sapply(composition, function(x) matrix(rep(1:k, times=unlist(strsplit(x,""))), ncol=k), simplify=F)
for (i in 2:(length(composition)-1)){                                                         #
composition.permutation = cbind(1, unique(permutations(k-1, k-1, order[[i]][,2:k], set=F)))
# Identify the subset of permutations that satisfy constraint (1):
order[[i]] = matrix(composition.permutation[apply(composition.permutation, 1, function(x){
length(unlist(sapply(2:k, function(i) setdiff(1:(x[i]), x[1:i]))))==0 }),], ncol=k)
}
nS = rapply(order, function(x) length(table(x)))
I = sapply(setNames(1:k,paste("s=",1:k,sep="")), simplify=F, function(s) order[nS==s])
return(I)
}
enumerateI(3)
I.list <- enumerateI(3)
class(I.list)
length(I.list)
I.list[1]
I.list[[1]
]
I.list[[2]]
I.list[[3]]
names(I.list)
class(I.list)
class(I.list[[1]])
I.list[[1]]
k3[[2]]
I/list[[2]]
I.list[[2]]
normGL = function(x, error, callthreshold, coding){ #, where x is a character vector of length one "REFcount, ALTcount"
REFcount <- as.numeric(unlist(strsplit(x,","))[1])
ALTcount <- as.numeric(unlist(strsplit(x,","))[2])
n <- REFcount + ALTcount
if(n == 0) return(setNames(rep(1/3, 3), c("AA","AB","BB"))) else
k <- ALTcount
e <- error
likelihood_AA <- choose(n, k) * e^k * (1-e)^(n-k)
likelihood_AB <- choose(n, k) * (0.50)^k * (0.50)^(n-k)
likelihood_BB <- choose(n, n-k) * (1-e)^k * e^(n-k)
normalization_constant <- sum(likelihood_AA, likelihood_AB, likelihood_BB)
GL_AA <- likelihood_AA/normalization_constant # Normalize the likelihoods such that they sum to one.
GL_AB <- likelihood_AB/normalization_constant
GL_BB <- likelihood_BB/normalization_constant
if(coding=="character"){GL <- c("AA"=GL_AA, "AB"=GL_AB, "BB"=GL_BB)}
if(coding=="numeric"){GL <- c("0"=GL_AA, "1"=GL_AB, "2"=GL_BB)}
if(is.na(callthreshold)){return(GL)} else
return(ifelse(max(GL)>callthreshold, names(which.max(GL)), NA))
}
normGL('2,2', 0.01, 0.99, coding='character')
install.packages('devtools')
library('devtools')
install_github("ac2278/BTRED")
?BTRED
BTRED
??BTRED
BTRED
BTRED()
ls()
install_github("kbroman/broman")
library('BTRED')
BTRED
library('devtools')
getwd()
setwd("/Volumes/CHARLIE/PAG2018/BIGRED")
document()
document()
